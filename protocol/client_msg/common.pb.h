// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client_msg/common.proto

#ifndef PROTOBUF_client_5fmsg_2fcommon_2eproto__INCLUDED
#define PROTOBUF_client_5fmsg_2fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace external {
namespace client {
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Location;
class LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Sensor;
class SensorDefaultTypeInternal;
extern SensorDefaultTypeInternal _Sensor_default_instance_;
class Sensor_Error;
class Sensor_ErrorDefaultTypeInternal;
extern Sensor_ErrorDefaultTypeInternal _Sensor_Error_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Signal_Geolocation;
class Signal_GeolocationDefaultTypeInternal;
extern Signal_GeolocationDefaultTypeInternal _Signal_Geolocation_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace client
}  // namespace external

namespace external {
namespace client {

namespace protobuf_client_5fmsg_2fcommon_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_client_5fmsg_2fcommon_2eproto

enum Sensor_Error_Type {
  Sensor_Error_Type_NONE = 0,
  Sensor_Error_Type_LOCATION = 1,
  Sensor_Error_Type_PPS = 2,
  Sensor_Error_Type_MISSION = 3,
  Sensor_Error_Type_Sensor_Error_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Sensor_Error_Type_Sensor_Error_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Sensor_Error_Type_IsValid(int value);
const Sensor_Error_Type Sensor_Error_Type_Type_MIN = Sensor_Error_Type_NONE;
const Sensor_Error_Type Sensor_Error_Type_Type_MAX = Sensor_Error_Type_MISSION;
const int Sensor_Error_Type_Type_ARRAYSIZE = Sensor_Error_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Sensor_Error_Type_descriptor();
inline const ::std::string& Sensor_Error_Type_Name(Sensor_Error_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Sensor_Error_Type_descriptor(), value);
}
inline bool Sensor_Error_Type_Parse(
    const ::std::string& name, Sensor_Error_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Sensor_Error_Type>(
    Sensor_Error_Type_descriptor(), name, value);
}
enum Sensor_Type {
  Sensor_Type_TCP = 0,
  Sensor_Type_ETHERNET = 1,
  Sensor_Type_Sensor_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Sensor_Type_Sensor_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Sensor_Type_IsValid(int value);
const Sensor_Type Sensor_Type_Type_MIN = Sensor_Type_TCP;
const Sensor_Type Sensor_Type_Type_MAX = Sensor_Type_ETHERNET;
const int Sensor_Type_Type_ARRAYSIZE = Sensor_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Sensor_Type_descriptor();
inline const ::std::string& Sensor_Type_Name(Sensor_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Sensor_Type_descriptor(), value);
}
inline bool Sensor_Type_Parse(
    const ::std::string& name, Sensor_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Sensor_Type>(
    Sensor_Type_descriptor(), name, value);
}
enum Signal_Type {
  Signal_Type_UNDEFINED = 0,
  Signal_Type_FM_NARROW = 1,
  Signal_Type_FM_WIDE = 2,
  Signal_Type_AM = 3,
  Signal_Type_FSK = 4,
  Signal_Type_USB = 5,
  Signal_Type_LSB = 6,
  Signal_Type_CW = 7,
  Signal_Type_Signal_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Signal_Type_Signal_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Signal_Type_IsValid(int value);
const Signal_Type Signal_Type_Type_MIN = Signal_Type_UNDEFINED;
const Signal_Type Signal_Type_Type_MAX = Signal_Type_CW;
const int Signal_Type_Type_ARRAYSIZE = Signal_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signal_Type_descriptor();
inline const ::std::string& Signal_Type_Name(Signal_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signal_Type_descriptor(), value);
}
inline bool Signal_Type_Parse(
    const ::std::string& name, Signal_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signal_Type>(
    Signal_Type_descriptor(), name, value);
}
enum Signal_Property {
  Signal_Property_FREQUENCY = 0,
  Signal_Property_BANDWIDTH = 1,
  Signal_Property_TIMESTAMP = 2,
  Signal_Property_DURATION = 3,
  Signal_Property_POWER = 4,
  Signal_Property_GEOLOCATION = 5,
  Signal_Property_TYPE = 6,
  Signal_Property_AUTOMATION = 7,
  Signal_Property_Signal_Property_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Signal_Property_Signal_Property_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Signal_Property_IsValid(int value);
const Signal_Property Signal_Property_Property_MIN = Signal_Property_FREQUENCY;
const Signal_Property Signal_Property_Property_MAX = Signal_Property_AUTOMATION;
const int Signal_Property_Property_ARRAYSIZE = Signal_Property_Property_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signal_Property_descriptor();
inline const ::std::string& Signal_Property_Name(Signal_Property value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signal_Property_descriptor(), value);
}
inline bool Signal_Property_Parse(
    const ::std::string& name, Signal_Property* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signal_Property>(
    Signal_Property_descriptor(), name, value);
}
// ===================================================================

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:external.client.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:external.client.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_client_5fmsg_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Version : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:external.client.Version) */ {
 public:
  Version();
  virtual ~Version();

  Version(const Version& from);

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(Version&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Version& default_instance();

  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Version* other);
  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Version* New() const PROTOBUF_FINAL { return New(NULL); }

  Version* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Version* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 major_number = 1;
  void clear_major_number();
  static const int kMajorNumberFieldNumber = 1;
  ::google::protobuf::uint32 major_number() const;
  void set_major_number(::google::protobuf::uint32 value);

  // uint32 minor_number = 2;
  void clear_minor_number();
  static const int kMinorNumberFieldNumber = 2;
  ::google::protobuf::uint32 minor_number() const;
  void set_minor_number(::google::protobuf::uint32 value);

  // uint32 build_number = 3;
  void clear_build_number();
  static const int kBuildNumberFieldNumber = 3;
  ::google::protobuf::uint32 build_number() const;
  void set_build_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:external.client.Version)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 major_number_;
  ::google::protobuf::uint32 minor_number_;
  ::google::protobuf::uint32 build_number_;
  mutable int _cached_size_;
  friend struct protobuf_client_5fmsg_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:external.client.Location) */ {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Location* other);
  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Location* New() const PROTOBUF_FINAL { return New(NULL); }

  Location* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double latitude = 1;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  double latitude() const;
  void set_latitude(double value);

  // double longitude = 2;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  double longitude() const;
  void set_longitude(double value);

  // @@protoc_insertion_point(class_scope:external.client.Location)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double latitude_;
  double longitude_;
  mutable int _cached_size_;
  friend struct protobuf_client_5fmsg_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sensor_Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:external.client.Sensor.Error) */ {
 public:
  Sensor_Error();
  virtual ~Sensor_Error();

  Sensor_Error(const Sensor_Error& from);

  inline Sensor_Error& operator=(const Sensor_Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sensor_Error(Sensor_Error&& from) noexcept
    : Sensor_Error() {
    *this = ::std::move(from);
  }

  inline Sensor_Error& operator=(Sensor_Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sensor_Error& default_instance();

  static inline const Sensor_Error* internal_default_instance() {
    return reinterpret_cast<const Sensor_Error*>(
               &_Sensor_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Sensor_Error* other);
  friend void swap(Sensor_Error& a, Sensor_Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sensor_Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Sensor_Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Sensor_Error& from);
  void MergeFrom(const Sensor_Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Sensor_Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Sensor_Error_Type Type;
  static const Type NONE =
    Sensor_Error_Type_NONE;
  static const Type LOCATION =
    Sensor_Error_Type_LOCATION;
  static const Type PPS =
    Sensor_Error_Type_PPS;
  static const Type MISSION =
    Sensor_Error_Type_MISSION;
  static inline bool Type_IsValid(int value) {
    return Sensor_Error_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Sensor_Error_Type_Type_MIN;
  static const Type Type_MAX =
    Sensor_Error_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Sensor_Error_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Sensor_Error_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Sensor_Error_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Sensor_Error_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .external.client.Sensor.Error.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::external::client::Sensor_Error_Type type() const;
  void set_type(::external::client::Sensor_Error_Type value);

  // @@protoc_insertion_point(class_scope:external.client.Sensor.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_client_5fmsg_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sensor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:external.client.Sensor) */ {
 public:
  Sensor();
  virtual ~Sensor();

  Sensor(const Sensor& from);

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sensor(Sensor&& from) noexcept
    : Sensor() {
    *this = ::std::move(from);
  }

  inline Sensor& operator=(Sensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sensor& default_instance();

  static inline const Sensor* internal_default_instance() {
    return reinterpret_cast<const Sensor*>(
               &_Sensor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Sensor* other);
  friend void swap(Sensor& a, Sensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sensor* New() const PROTOBUF_FINAL { return New(NULL); }

  Sensor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Sensor& from);
  void MergeFrom(const Sensor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Sensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Sensor_Error Error;

  typedef Sensor_Type Type;
  static const Type TCP =
    Sensor_Type_TCP;
  static const Type ETHERNET =
    Sensor_Type_ETHERNET;
  static inline bool Type_IsValid(int value) {
    return Sensor_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Sensor_Type_Type_MIN;
  static const Type Type_MAX =
    Sensor_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Sensor_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Sensor_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Sensor_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Sensor_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .external.client.Sensor.Error error = 10;
  int error_size() const;
  void clear_error();
  static const int kErrorFieldNumber = 10;
  const ::external::client::Sensor_Error& error(int index) const;
  ::external::client::Sensor_Error* mutable_error(int index);
  ::external::client::Sensor_Error* add_error();
  ::google::protobuf::RepeatedPtrField< ::external::client::Sensor_Error >*
      mutable_error();
  const ::google::protobuf::RepeatedPtrField< ::external::client::Sensor_Error >&
      error() const;

  // string address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // .external.client.Version software_version = 6;
  bool has_software_version() const;
  void clear_software_version();
  static const int kSoftwareVersionFieldNumber = 6;
  const ::external::client::Version& software_version() const;
  ::external::client::Version* mutable_software_version();
  ::external::client::Version* release_software_version();
  void set_allocated_software_version(::external::client::Version* software_version);

  // .external.client.Version hardware_version = 7;
  bool has_hardware_version() const;
  void clear_hardware_version();
  static const int kHardwareVersionFieldNumber = 7;
  const ::external::client::Version& hardware_version() const;
  ::external::client::Version* mutable_hardware_version();
  ::external::client::Version* release_hardware_version();
  void set_allocated_hardware_version(::external::client::Version* hardware_version);

  // .external.client.Location location = 8;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 8;
  const ::external::client::Location& location() const;
  ::external::client::Location* mutable_location();
  ::external::client::Location* release_location();
  void set_allocated_location(::external::client::Location* location);

  // uint64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // int32 port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // bool actived = 4;
  void clear_actived();
  static const int kActivedFieldNumber = 4;
  bool actived() const;
  void set_actived(bool value);

  // bool connected = 5;
  void clear_connected();
  static const int kConnectedFieldNumber = 5;
  bool connected() const;
  void set_connected(bool value);

  // .external.client.Sensor.Type type = 9;
  void clear_type();
  static const int kTypeFieldNumber = 9;
  ::external::client::Sensor_Type type() const;
  void set_type(::external::client::Sensor_Type value);

  // @@protoc_insertion_point(class_scope:external.client.Sensor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::external::client::Sensor_Error > error_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::external::client::Version* software_version_;
  ::external::client::Version* hardware_version_;
  ::external::client::Location* location_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::int32 port_;
  bool actived_;
  bool connected_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_client_5fmsg_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signal_Geolocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:external.client.Signal.Geolocation) */ {
 public:
  Signal_Geolocation();
  virtual ~Signal_Geolocation();

  Signal_Geolocation(const Signal_Geolocation& from);

  inline Signal_Geolocation& operator=(const Signal_Geolocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal_Geolocation(Signal_Geolocation&& from) noexcept
    : Signal_Geolocation() {
    *this = ::std::move(from);
  }

  inline Signal_Geolocation& operator=(Signal_Geolocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal_Geolocation& default_instance();

  static inline const Signal_Geolocation* internal_default_instance() {
    return reinterpret_cast<const Signal_Geolocation*>(
               &_Signal_Geolocation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Signal_Geolocation* other);
  friend void swap(Signal_Geolocation& a, Signal_Geolocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal_Geolocation* New() const PROTOBUF_FINAL { return New(NULL); }

  Signal_Geolocation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Signal_Geolocation& from);
  void MergeFrom(const Signal_Geolocation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Signal_Geolocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .external.client.Sensor sensor = 2;
  int sensor_size() const;
  void clear_sensor();
  static const int kSensorFieldNumber = 2;
  const ::external::client::Sensor& sensor(int index) const;
  ::external::client::Sensor* mutable_sensor(int index);
  ::external::client::Sensor* add_sensor();
  ::google::protobuf::RepeatedPtrField< ::external::client::Sensor >*
      mutable_sensor();
  const ::google::protobuf::RepeatedPtrField< ::external::client::Sensor >&
      sensor() const;

  // repeated float confidence = 3;
  int confidence_size() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 3;
  float confidence(int index) const;
  void set_confidence(int index, float value);
  void add_confidence(float value);
  const ::google::protobuf::RepeatedField< float >&
      confidence() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_confidence();

  // repeated .external.client.Location hypebol = 4;
  int hypebol_size() const;
  void clear_hypebol();
  static const int kHypebolFieldNumber = 4;
  const ::external::client::Location& hypebol(int index) const;
  ::external::client::Location* mutable_hypebol(int index);
  ::external::client::Location* add_hypebol();
  ::google::protobuf::RepeatedPtrField< ::external::client::Location >*
      mutable_hypebol();
  const ::google::protobuf::RepeatedPtrField< ::external::client::Location >&
      hypebol() const;

  // repeated uint64 offset_time = 5;
  int offset_time_size() const;
  void clear_offset_time();
  static const int kOffsetTimeFieldNumber = 5;
  ::google::protobuf::uint64 offset_time(int index) const;
  void set_offset_time(int index, ::google::protobuf::uint64 value);
  void add_offset_time(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      offset_time() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_offset_time();

  // .external.client.Location location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::external::client::Location& location() const;
  ::external::client::Location* mutable_location();
  ::external::client::Location* release_location();
  void set_allocated_location(::external::client::Location* location);

  // @@protoc_insertion_point(class_scope:external.client.Signal.Geolocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::external::client::Sensor > sensor_;
  ::google::protobuf::RepeatedField< float > confidence_;
  mutable int _confidence_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::external::client::Location > hypebol_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > offset_time_;
  mutable int _offset_time_cached_byte_size_;
  ::external::client::Location* location_;
  mutable int _cached_size_;
  friend struct protobuf_client_5fmsg_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:external.client.Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Signal* other);
  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const PROTOBUF_FINAL { return New(NULL); }

  Signal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Signal_Geolocation Geolocation;

  typedef Signal_Type Type;
  static const Type UNDEFINED =
    Signal_Type_UNDEFINED;
  static const Type FM_NARROW =
    Signal_Type_FM_NARROW;
  static const Type FM_WIDE =
    Signal_Type_FM_WIDE;
  static const Type AM =
    Signal_Type_AM;
  static const Type FSK =
    Signal_Type_FSK;
  static const Type USB =
    Signal_Type_USB;
  static const Type LSB =
    Signal_Type_LSB;
  static const Type CW =
    Signal_Type_CW;
  static inline bool Type_IsValid(int value) {
    return Signal_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Signal_Type_Type_MIN;
  static const Type Type_MAX =
    Signal_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Signal_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Signal_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Signal_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Signal_Type_Parse(name, value);
  }

  typedef Signal_Property Property;
  static const Property FREQUENCY =
    Signal_Property_FREQUENCY;
  static const Property BANDWIDTH =
    Signal_Property_BANDWIDTH;
  static const Property TIMESTAMP =
    Signal_Property_TIMESTAMP;
  static const Property DURATION =
    Signal_Property_DURATION;
  static const Property POWER =
    Signal_Property_POWER;
  static const Property GEOLOCATION =
    Signal_Property_GEOLOCATION;
  static const Property TYPE =
    Signal_Property_TYPE;
  static const Property AUTOMATION =
    Signal_Property_AUTOMATION;
  static inline bool Property_IsValid(int value) {
    return Signal_Property_IsValid(value);
  }
  static const Property Property_MIN =
    Signal_Property_Property_MIN;
  static const Property Property_MAX =
    Signal_Property_Property_MAX;
  static const int Property_ARRAYSIZE =
    Signal_Property_Property_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Property_descriptor() {
    return Signal_Property_descriptor();
  }
  static inline const ::std::string& Property_Name(Property value) {
    return Signal_Property_Name(value);
  }
  static inline bool Property_Parse(const ::std::string& name,
      Property* value) {
    return Signal_Property_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .external.client.Signal.Geolocation geolocation = 8;
  bool has_geolocation() const;
  void clear_geolocation();
  static const int kGeolocationFieldNumber = 8;
  const ::external::client::Signal_Geolocation& geolocation() const;
  ::external::client::Signal_Geolocation* mutable_geolocation();
  ::external::client::Signal_Geolocation* release_geolocation();
  void set_allocated_geolocation(::external::client::Signal_Geolocation* geolocation);

  // uint64 properties = 1;
  void clear_properties();
  static const int kPropertiesFieldNumber = 1;
  ::google::protobuf::uint64 properties() const;
  void set_properties(::google::protobuf::uint64 value);

  // uint64 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // uint64 frequency = 3;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 3;
  ::google::protobuf::uint64 frequency() const;
  void set_frequency(::google::protobuf::uint64 value);

  // uint64 timestamp = 5;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // uint32 bandwidth = 4;
  void clear_bandwidth();
  static const int kBandwidthFieldNumber = 4;
  ::google::protobuf::uint32 bandwidth() const;
  void set_bandwidth(::google::protobuf::uint32 value);

  // float power = 7;
  void clear_power();
  static const int kPowerFieldNumber = 7;
  float power() const;
  void set_power(float value);

  // uint64 duration = 6;
  void clear_duration();
  static const int kDurationFieldNumber = 6;
  ::google::protobuf::uint64 duration() const;
  void set_duration(::google::protobuf::uint64 value);

  // uint64 automation = 10;
  void clear_automation();
  static const int kAutomationFieldNumber = 10;
  ::google::protobuf::uint64 automation() const;
  void set_automation(::google::protobuf::uint64 value);

  // .external.client.Signal.Type type = 9;
  void clear_type();
  static const int kTypeFieldNumber = 9;
  ::external::client::Signal_Type type() const;
  void set_type(::external::client::Signal_Type value);

  // @@protoc_insertion_point(class_scope:external.client.Signal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::external::client::Signal_Geolocation* geolocation_;
  ::google::protobuf::uint64 properties_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 frequency_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 bandwidth_;
  float power_;
  ::google::protobuf::uint64 duration_;
  ::google::protobuf::uint64 automation_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_client_5fmsg_2fcommon_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Error

// int32 code = 1;
inline void Error::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 Error::code() const {
  // @@protoc_insertion_point(field_get:external.client.Error.code)
  return code_;
}
inline void Error::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:external.client.Error.code)
}

// string message = 2;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:external.client.Error.message)
  return message_.GetNoArena();
}
inline void Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:external.client.Error.message)
}
#if LANG_CXX11
inline void Error::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:external.client.Error.message)
}
#endif
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:external.client.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:external.client.Error.message)
}
inline ::std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:external.client.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:external.client.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:external.client.Error.message)
}

// -------------------------------------------------------------------

// Version

// uint32 major_number = 1;
inline void Version::clear_major_number() {
  major_number_ = 0u;
}
inline ::google::protobuf::uint32 Version::major_number() const {
  // @@protoc_insertion_point(field_get:external.client.Version.major_number)
  return major_number_;
}
inline void Version::set_major_number(::google::protobuf::uint32 value) {
  
  major_number_ = value;
  // @@protoc_insertion_point(field_set:external.client.Version.major_number)
}

// uint32 minor_number = 2;
inline void Version::clear_minor_number() {
  minor_number_ = 0u;
}
inline ::google::protobuf::uint32 Version::minor_number() const {
  // @@protoc_insertion_point(field_get:external.client.Version.minor_number)
  return minor_number_;
}
inline void Version::set_minor_number(::google::protobuf::uint32 value) {
  
  minor_number_ = value;
  // @@protoc_insertion_point(field_set:external.client.Version.minor_number)
}

// uint32 build_number = 3;
inline void Version::clear_build_number() {
  build_number_ = 0u;
}
inline ::google::protobuf::uint32 Version::build_number() const {
  // @@protoc_insertion_point(field_get:external.client.Version.build_number)
  return build_number_;
}
inline void Version::set_build_number(::google::protobuf::uint32 value) {
  
  build_number_ = value;
  // @@protoc_insertion_point(field_set:external.client.Version.build_number)
}

// -------------------------------------------------------------------

// Location

// double latitude = 1;
inline void Location::clear_latitude() {
  latitude_ = 0;
}
inline double Location::latitude() const {
  // @@protoc_insertion_point(field_get:external.client.Location.latitude)
  return latitude_;
}
inline void Location::set_latitude(double value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:external.client.Location.latitude)
}

// double longitude = 2;
inline void Location::clear_longitude() {
  longitude_ = 0;
}
inline double Location::longitude() const {
  // @@protoc_insertion_point(field_get:external.client.Location.longitude)
  return longitude_;
}
inline void Location::set_longitude(double value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:external.client.Location.longitude)
}

// -------------------------------------------------------------------

// Sensor_Error

// .external.client.Sensor.Error.Type type = 1;
inline void Sensor_Error::clear_type() {
  type_ = 0;
}
inline ::external::client::Sensor_Error_Type Sensor_Error::type() const {
  // @@protoc_insertion_point(field_get:external.client.Sensor.Error.type)
  return static_cast< ::external::client::Sensor_Error_Type >(type_);
}
inline void Sensor_Error::set_type(::external::client::Sensor_Error_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:external.client.Sensor.Error.type)
}

// string message = 2;
inline void Sensor_Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sensor_Error::message() const {
  // @@protoc_insertion_point(field_get:external.client.Sensor.Error.message)
  return message_.GetNoArena();
}
inline void Sensor_Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:external.client.Sensor.Error.message)
}
#if LANG_CXX11
inline void Sensor_Error::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:external.client.Sensor.Error.message)
}
#endif
inline void Sensor_Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:external.client.Sensor.Error.message)
}
inline void Sensor_Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:external.client.Sensor.Error.message)
}
inline ::std::string* Sensor_Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:external.client.Sensor.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor_Error::release_message() {
  // @@protoc_insertion_point(field_release:external.client.Sensor.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor_Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:external.client.Sensor.Error.message)
}

// -------------------------------------------------------------------

// Sensor

// uint64 id = 1;
inline void Sensor::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Sensor::id() const {
  // @@protoc_insertion_point(field_get:external.client.Sensor.id)
  return id_;
}
inline void Sensor::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:external.client.Sensor.id)
}

// string address = 2;
inline void Sensor::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sensor::address() const {
  // @@protoc_insertion_point(field_get:external.client.Sensor.address)
  return address_.GetNoArena();
}
inline void Sensor::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:external.client.Sensor.address)
}
#if LANG_CXX11
inline void Sensor::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:external.client.Sensor.address)
}
#endif
inline void Sensor::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:external.client.Sensor.address)
}
inline void Sensor::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:external.client.Sensor.address)
}
inline ::std::string* Sensor::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:external.client.Sensor.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_address() {
  // @@protoc_insertion_point(field_release:external.client.Sensor.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:external.client.Sensor.address)
}

// int32 port = 3;
inline void Sensor::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 Sensor::port() const {
  // @@protoc_insertion_point(field_get:external.client.Sensor.port)
  return port_;
}
inline void Sensor::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:external.client.Sensor.port)
}

// bool actived = 4;
inline void Sensor::clear_actived() {
  actived_ = false;
}
inline bool Sensor::actived() const {
  // @@protoc_insertion_point(field_get:external.client.Sensor.actived)
  return actived_;
}
inline void Sensor::set_actived(bool value) {
  
  actived_ = value;
  // @@protoc_insertion_point(field_set:external.client.Sensor.actived)
}

// bool connected = 5;
inline void Sensor::clear_connected() {
  connected_ = false;
}
inline bool Sensor::connected() const {
  // @@protoc_insertion_point(field_get:external.client.Sensor.connected)
  return connected_;
}
inline void Sensor::set_connected(bool value) {
  
  connected_ = value;
  // @@protoc_insertion_point(field_set:external.client.Sensor.connected)
}

// .external.client.Version software_version = 6;
inline bool Sensor::has_software_version() const {
  return this != internal_default_instance() && software_version_ != NULL;
}
inline void Sensor::clear_software_version() {
  if (GetArenaNoVirtual() == NULL && software_version_ != NULL) delete software_version_;
  software_version_ = NULL;
}
inline const ::external::client::Version& Sensor::software_version() const {
  const ::external::client::Version* p = software_version_;
  // @@protoc_insertion_point(field_get:external.client.Sensor.software_version)
  return p != NULL ? *p : *reinterpret_cast<const ::external::client::Version*>(
      &::external::client::_Version_default_instance_);
}
inline ::external::client::Version* Sensor::mutable_software_version() {
  
  if (software_version_ == NULL) {
    software_version_ = new ::external::client::Version;
  }
  // @@protoc_insertion_point(field_mutable:external.client.Sensor.software_version)
  return software_version_;
}
inline ::external::client::Version* Sensor::release_software_version() {
  // @@protoc_insertion_point(field_release:external.client.Sensor.software_version)
  
  ::external::client::Version* temp = software_version_;
  software_version_ = NULL;
  return temp;
}
inline void Sensor::set_allocated_software_version(::external::client::Version* software_version) {
  delete software_version_;
  software_version_ = software_version;
  if (software_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:external.client.Sensor.software_version)
}

// .external.client.Version hardware_version = 7;
inline bool Sensor::has_hardware_version() const {
  return this != internal_default_instance() && hardware_version_ != NULL;
}
inline void Sensor::clear_hardware_version() {
  if (GetArenaNoVirtual() == NULL && hardware_version_ != NULL) delete hardware_version_;
  hardware_version_ = NULL;
}
inline const ::external::client::Version& Sensor::hardware_version() const {
  const ::external::client::Version* p = hardware_version_;
  // @@protoc_insertion_point(field_get:external.client.Sensor.hardware_version)
  return p != NULL ? *p : *reinterpret_cast<const ::external::client::Version*>(
      &::external::client::_Version_default_instance_);
}
inline ::external::client::Version* Sensor::mutable_hardware_version() {
  
  if (hardware_version_ == NULL) {
    hardware_version_ = new ::external::client::Version;
  }
  // @@protoc_insertion_point(field_mutable:external.client.Sensor.hardware_version)
  return hardware_version_;
}
inline ::external::client::Version* Sensor::release_hardware_version() {
  // @@protoc_insertion_point(field_release:external.client.Sensor.hardware_version)
  
  ::external::client::Version* temp = hardware_version_;
  hardware_version_ = NULL;
  return temp;
}
inline void Sensor::set_allocated_hardware_version(::external::client::Version* hardware_version) {
  delete hardware_version_;
  hardware_version_ = hardware_version;
  if (hardware_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:external.client.Sensor.hardware_version)
}

// .external.client.Location location = 8;
inline bool Sensor::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Sensor::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::external::client::Location& Sensor::location() const {
  const ::external::client::Location* p = location_;
  // @@protoc_insertion_point(field_get:external.client.Sensor.location)
  return p != NULL ? *p : *reinterpret_cast<const ::external::client::Location*>(
      &::external::client::_Location_default_instance_);
}
inline ::external::client::Location* Sensor::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::external::client::Location;
  }
  // @@protoc_insertion_point(field_mutable:external.client.Sensor.location)
  return location_;
}
inline ::external::client::Location* Sensor::release_location() {
  // @@protoc_insertion_point(field_release:external.client.Sensor.location)
  
  ::external::client::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Sensor::set_allocated_location(::external::client::Location* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:external.client.Sensor.location)
}

// .external.client.Sensor.Type type = 9;
inline void Sensor::clear_type() {
  type_ = 0;
}
inline ::external::client::Sensor_Type Sensor::type() const {
  // @@protoc_insertion_point(field_get:external.client.Sensor.type)
  return static_cast< ::external::client::Sensor_Type >(type_);
}
inline void Sensor::set_type(::external::client::Sensor_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:external.client.Sensor.type)
}

// repeated .external.client.Sensor.Error error = 10;
inline int Sensor::error_size() const {
  return error_.size();
}
inline void Sensor::clear_error() {
  error_.Clear();
}
inline const ::external::client::Sensor_Error& Sensor::error(int index) const {
  // @@protoc_insertion_point(field_get:external.client.Sensor.error)
  return error_.Get(index);
}
inline ::external::client::Sensor_Error* Sensor::mutable_error(int index) {
  // @@protoc_insertion_point(field_mutable:external.client.Sensor.error)
  return error_.Mutable(index);
}
inline ::external::client::Sensor_Error* Sensor::add_error() {
  // @@protoc_insertion_point(field_add:external.client.Sensor.error)
  return error_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::external::client::Sensor_Error >*
Sensor::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:external.client.Sensor.error)
  return &error_;
}
inline const ::google::protobuf::RepeatedPtrField< ::external::client::Sensor_Error >&
Sensor::error() const {
  // @@protoc_insertion_point(field_list:external.client.Sensor.error)
  return error_;
}

// -------------------------------------------------------------------

// Signal_Geolocation

// .external.client.Location location = 1;
inline bool Signal_Geolocation::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Signal_Geolocation::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::external::client::Location& Signal_Geolocation::location() const {
  const ::external::client::Location* p = location_;
  // @@protoc_insertion_point(field_get:external.client.Signal.Geolocation.location)
  return p != NULL ? *p : *reinterpret_cast<const ::external::client::Location*>(
      &::external::client::_Location_default_instance_);
}
inline ::external::client::Location* Signal_Geolocation::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::external::client::Location;
  }
  // @@protoc_insertion_point(field_mutable:external.client.Signal.Geolocation.location)
  return location_;
}
inline ::external::client::Location* Signal_Geolocation::release_location() {
  // @@protoc_insertion_point(field_release:external.client.Signal.Geolocation.location)
  
  ::external::client::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Signal_Geolocation::set_allocated_location(::external::client::Location* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:external.client.Signal.Geolocation.location)
}

// repeated .external.client.Sensor sensor = 2;
inline int Signal_Geolocation::sensor_size() const {
  return sensor_.size();
}
inline void Signal_Geolocation::clear_sensor() {
  sensor_.Clear();
}
inline const ::external::client::Sensor& Signal_Geolocation::sensor(int index) const {
  // @@protoc_insertion_point(field_get:external.client.Signal.Geolocation.sensor)
  return sensor_.Get(index);
}
inline ::external::client::Sensor* Signal_Geolocation::mutable_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:external.client.Signal.Geolocation.sensor)
  return sensor_.Mutable(index);
}
inline ::external::client::Sensor* Signal_Geolocation::add_sensor() {
  // @@protoc_insertion_point(field_add:external.client.Signal.Geolocation.sensor)
  return sensor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::external::client::Sensor >*
Signal_Geolocation::mutable_sensor() {
  // @@protoc_insertion_point(field_mutable_list:external.client.Signal.Geolocation.sensor)
  return &sensor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::external::client::Sensor >&
Signal_Geolocation::sensor() const {
  // @@protoc_insertion_point(field_list:external.client.Signal.Geolocation.sensor)
  return sensor_;
}

// repeated float confidence = 3;
inline int Signal_Geolocation::confidence_size() const {
  return confidence_.size();
}
inline void Signal_Geolocation::clear_confidence() {
  confidence_.Clear();
}
inline float Signal_Geolocation::confidence(int index) const {
  // @@protoc_insertion_point(field_get:external.client.Signal.Geolocation.confidence)
  return confidence_.Get(index);
}
inline void Signal_Geolocation::set_confidence(int index, float value) {
  confidence_.Set(index, value);
  // @@protoc_insertion_point(field_set:external.client.Signal.Geolocation.confidence)
}
inline void Signal_Geolocation::add_confidence(float value) {
  confidence_.Add(value);
  // @@protoc_insertion_point(field_add:external.client.Signal.Geolocation.confidence)
}
inline const ::google::protobuf::RepeatedField< float >&
Signal_Geolocation::confidence() const {
  // @@protoc_insertion_point(field_list:external.client.Signal.Geolocation.confidence)
  return confidence_;
}
inline ::google::protobuf::RepeatedField< float >*
Signal_Geolocation::mutable_confidence() {
  // @@protoc_insertion_point(field_mutable_list:external.client.Signal.Geolocation.confidence)
  return &confidence_;
}

// repeated .external.client.Location hypebol = 4;
inline int Signal_Geolocation::hypebol_size() const {
  return hypebol_.size();
}
inline void Signal_Geolocation::clear_hypebol() {
  hypebol_.Clear();
}
inline const ::external::client::Location& Signal_Geolocation::hypebol(int index) const {
  // @@protoc_insertion_point(field_get:external.client.Signal.Geolocation.hypebol)
  return hypebol_.Get(index);
}
inline ::external::client::Location* Signal_Geolocation::mutable_hypebol(int index) {
  // @@protoc_insertion_point(field_mutable:external.client.Signal.Geolocation.hypebol)
  return hypebol_.Mutable(index);
}
inline ::external::client::Location* Signal_Geolocation::add_hypebol() {
  // @@protoc_insertion_point(field_add:external.client.Signal.Geolocation.hypebol)
  return hypebol_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::external::client::Location >*
Signal_Geolocation::mutable_hypebol() {
  // @@protoc_insertion_point(field_mutable_list:external.client.Signal.Geolocation.hypebol)
  return &hypebol_;
}
inline const ::google::protobuf::RepeatedPtrField< ::external::client::Location >&
Signal_Geolocation::hypebol() const {
  // @@protoc_insertion_point(field_list:external.client.Signal.Geolocation.hypebol)
  return hypebol_;
}

// repeated uint64 offset_time = 5;
inline int Signal_Geolocation::offset_time_size() const {
  return offset_time_.size();
}
inline void Signal_Geolocation::clear_offset_time() {
  offset_time_.Clear();
}
inline ::google::protobuf::uint64 Signal_Geolocation::offset_time(int index) const {
  // @@protoc_insertion_point(field_get:external.client.Signal.Geolocation.offset_time)
  return offset_time_.Get(index);
}
inline void Signal_Geolocation::set_offset_time(int index, ::google::protobuf::uint64 value) {
  offset_time_.Set(index, value);
  // @@protoc_insertion_point(field_set:external.client.Signal.Geolocation.offset_time)
}
inline void Signal_Geolocation::add_offset_time(::google::protobuf::uint64 value) {
  offset_time_.Add(value);
  // @@protoc_insertion_point(field_add:external.client.Signal.Geolocation.offset_time)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Signal_Geolocation::offset_time() const {
  // @@protoc_insertion_point(field_list:external.client.Signal.Geolocation.offset_time)
  return offset_time_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Signal_Geolocation::mutable_offset_time() {
  // @@protoc_insertion_point(field_mutable_list:external.client.Signal.Geolocation.offset_time)
  return &offset_time_;
}

// -------------------------------------------------------------------

// Signal

// uint64 properties = 1;
inline void Signal::clear_properties() {
  properties_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Signal::properties() const {
  // @@protoc_insertion_point(field_get:external.client.Signal.properties)
  return properties_;
}
inline void Signal::set_properties(::google::protobuf::uint64 value) {
  
  properties_ = value;
  // @@protoc_insertion_point(field_set:external.client.Signal.properties)
}

// uint64 id = 2;
inline void Signal::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Signal::id() const {
  // @@protoc_insertion_point(field_get:external.client.Signal.id)
  return id_;
}
inline void Signal::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:external.client.Signal.id)
}

// uint64 frequency = 3;
inline void Signal::clear_frequency() {
  frequency_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Signal::frequency() const {
  // @@protoc_insertion_point(field_get:external.client.Signal.frequency)
  return frequency_;
}
inline void Signal::set_frequency(::google::protobuf::uint64 value) {
  
  frequency_ = value;
  // @@protoc_insertion_point(field_set:external.client.Signal.frequency)
}

// uint32 bandwidth = 4;
inline void Signal::clear_bandwidth() {
  bandwidth_ = 0u;
}
inline ::google::protobuf::uint32 Signal::bandwidth() const {
  // @@protoc_insertion_point(field_get:external.client.Signal.bandwidth)
  return bandwidth_;
}
inline void Signal::set_bandwidth(::google::protobuf::uint32 value) {
  
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:external.client.Signal.bandwidth)
}

// uint64 timestamp = 5;
inline void Signal::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Signal::timestamp() const {
  // @@protoc_insertion_point(field_get:external.client.Signal.timestamp)
  return timestamp_;
}
inline void Signal::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:external.client.Signal.timestamp)
}

// uint64 duration = 6;
inline void Signal::clear_duration() {
  duration_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Signal::duration() const {
  // @@protoc_insertion_point(field_get:external.client.Signal.duration)
  return duration_;
}
inline void Signal::set_duration(::google::protobuf::uint64 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:external.client.Signal.duration)
}

// float power = 7;
inline void Signal::clear_power() {
  power_ = 0;
}
inline float Signal::power() const {
  // @@protoc_insertion_point(field_get:external.client.Signal.power)
  return power_;
}
inline void Signal::set_power(float value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:external.client.Signal.power)
}

// .external.client.Signal.Geolocation geolocation = 8;
inline bool Signal::has_geolocation() const {
  return this != internal_default_instance() && geolocation_ != NULL;
}
inline void Signal::clear_geolocation() {
  if (GetArenaNoVirtual() == NULL && geolocation_ != NULL) delete geolocation_;
  geolocation_ = NULL;
}
inline const ::external::client::Signal_Geolocation& Signal::geolocation() const {
  const ::external::client::Signal_Geolocation* p = geolocation_;
  // @@protoc_insertion_point(field_get:external.client.Signal.geolocation)
  return p != NULL ? *p : *reinterpret_cast<const ::external::client::Signal_Geolocation*>(
      &::external::client::_Signal_Geolocation_default_instance_);
}
inline ::external::client::Signal_Geolocation* Signal::mutable_geolocation() {
  
  if (geolocation_ == NULL) {
    geolocation_ = new ::external::client::Signal_Geolocation;
  }
  // @@protoc_insertion_point(field_mutable:external.client.Signal.geolocation)
  return geolocation_;
}
inline ::external::client::Signal_Geolocation* Signal::release_geolocation() {
  // @@protoc_insertion_point(field_release:external.client.Signal.geolocation)
  
  ::external::client::Signal_Geolocation* temp = geolocation_;
  geolocation_ = NULL;
  return temp;
}
inline void Signal::set_allocated_geolocation(::external::client::Signal_Geolocation* geolocation) {
  delete geolocation_;
  geolocation_ = geolocation;
  if (geolocation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:external.client.Signal.geolocation)
}

// .external.client.Signal.Type type = 9;
inline void Signal::clear_type() {
  type_ = 0;
}
inline ::external::client::Signal_Type Signal::type() const {
  // @@protoc_insertion_point(field_get:external.client.Signal.type)
  return static_cast< ::external::client::Signal_Type >(type_);
}
inline void Signal::set_type(::external::client::Signal_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:external.client.Signal.type)
}

// uint64 automation = 10;
inline void Signal::clear_automation() {
  automation_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Signal::automation() const {
  // @@protoc_insertion_point(field_get:external.client.Signal.automation)
  return automation_;
}
inline void Signal::set_automation(::google::protobuf::uint64 value) {
  
  automation_ = value;
  // @@protoc_insertion_point(field_set:external.client.Signal.automation)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace client
}  // namespace external

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::external::client::Sensor_Error_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::external::client::Sensor_Error_Type>() {
  return ::external::client::Sensor_Error_Type_descriptor();
}
template <> struct is_proto_enum< ::external::client::Sensor_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::external::client::Sensor_Type>() {
  return ::external::client::Sensor_Type_descriptor();
}
template <> struct is_proto_enum< ::external::client::Signal_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::external::client::Signal_Type>() {
  return ::external::client::Signal_Type_descriptor();
}
template <> struct is_proto_enum< ::external::client::Signal_Property> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::external::client::Signal_Property>() {
  return ::external::client::Signal_Property_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_5fmsg_2fcommon_2eproto__INCLUDED
